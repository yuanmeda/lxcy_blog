## 微前端产生的背景和意义？它的产生解决了什么问题？

- https://zhuanlan.zhihu.com/p/415900889

  Web 应用在开发大规模应用和涉及多研发团队协作时遇到的困境。即 Web 应用的复杂度和参与人数以爆炸式的增长速度，需要一种新的架构模式来解决现有的困境，同时兼顾开发体验和用户体验。

  传统的 web 应用的两种设计模式：a. SPA 应用，多个系统在同一个仓库进行管理，用户体验提升，但是降低了开发体验；b. MPA 应用，将对个系统分别在不同的仓库进行管理，在首页聚合所有应用的入口，提升了开发体验，却降低了用户体验，增强了用户体验产品的割裂感。

  所以，传统的分而治之的策略已经无法应对现在 Web 应用的复杂性，因此衍生出了微前端这样一种新的架构模式。延续了分而治之的设计模式，不过却以全新的方法来实现。

  在实际的开发工作中我们还有一些切实的感受：

1、随着业务的深入和复杂，项目庞大会引起一些逻辑定位问题、打包速度问题、部署上线问题。小幅度的代码的变更都需要整个项目重新打包编译发布。

2、技术发展迅猛，旧有项目技术栈陈旧的前提下，无法快速使用新技术进行迭代开发，否则需要重构。

## 那么我们需要具备什么样的技术能力或者架构去解决以上问题？

或者说我们希望以什么样的开发模式去达到更好的用户体验？

- 子系统不限技术栈，能够独立运行、独立开发、独立部署（迭代互不阻塞等等），空间上相互隔离（防止 JS、css 污染）；
- 子系统之间能够实现基础库的代码复用，通信以及数据共享（用户信息）；
- 子系统间同灰度
- 系统是单一的产品，不割裂
- 提供集中子系统权限管控；
- 项目的监控能够细化到子系统

## 微前端是什么？

微前端是一种类似微服务的一种新的架构模式，即将 Web 应用由单一的单页面应用转变为多个小型前端应用聚合为一的应用。然后各个前端应用还可以独立运行、独立开发、独立部署。

## 实现微前端的方案

1. 路由转发

将路由跳转交给服务端，当我们访问一个路由的时候，后端进行重定向。当后端收到 a 路由的时候，指向 a 系统，当收到 b 路由的时候指向另外一个系统。因此实现了系统之间的隔离。分享用户信息可以使用 cookie、localStorage 等。每次路由匹配，都会进行路由刷新，因此也防止了 JS、css 污染问题。

> 优点： 简单，可快速配置
> 缺点：每次跳转都相当于重新刷新一次页面，不是页面内进行跳转，降低了用户体验。且无法进行头部导航共享等。

2. iframe 嵌套。

通过创建一个父程序，在父程序中监听路由的变化，卸载或加载响应的子应用 iframe。每一个 iframe 就相当于一个单独的页面，iframe 具有天然的 JS 和 CSS 隔离。可以使用 postMessage 或者 contentWindow 的方式进行数据共享。

> 优点：实现简单，自带沙盒特性。
> 缺点：

- iframe 样式兼容问题，功能和业务性兼容问题（比如弹窗位置，iframe 的视窗宽高限制问题）。
- iframe 与上层应用并非同一个文档上下文导致的一些问题
  - 事件无法冒泡到顶层
  - 主应用劫持快捷键操作(???)
  - 跳转路径无法与上层文档同步，刷新丢失路由状态
  - iframe 登录态无法共享，子应用需要重新登录
  - iframe 在禁用三方 cookie 时，iframe 平台服务不可用
  - iframe 应用加载失败，内容发生错误主应用无法感知
  - 无法共享基础库进一步减少包体积
  - 事件通信繁琐且限制多（https://blog.csdn.net/willspace/article/details/49003963）

3. 纯 Web component 开发 （应用普及度很低）

参考https://www.ruanyifeng.com/blog/2019/08/web_components.html。将每个子应用采用web components 进行开发。

> 优点： 每个子应用拥有独立的 script 和 css, 也可以单独部署
> 缺点： 需要对之前的子系统都进行改造，并且通信方面较为复杂

4. 组合式应用路由分发

整体是： 基座+子应用分治。

每个子应用独立运行，打包部署。在基座应用中进行路由管理。不同的路由对应不同的子应用。路由发生变更，就会进行上一个子应用的卸载，卸载完成之后再加载新的子应用。

> 优点：纯前端改造，相比于路由式无刷新，体验感良好。
> 缺点：需要解决样式冲突，JS 污染问题，通信技术等。

## 目前采用的方案

目前微前端采用的技术方案是`组合式应用路由分发`，single-spa 和 qiankun 是它的两种实践；那么需要手动实现 JS 沙盒环境、css 的样式重叠或者冲突问题、通信技术问题。

> css 样式冲突解决方案

- 基于不同的前缀，全局定义唯一的 css 前缀，使用 less 或者 sass 作用域嵌套即可。
- css module 或者类似 vue 的 scoped
- css in js (http://www.ruanyifeng.com/blog/2017/04/css_in_js.html)

> JS 沙盒环境

JS 的污染主要是看作用域，如果在全局的 window 上挂在相同的属性或者方法，就会出现覆盖冲突。所以沙盒环境主要做的就是一个 JS 作用域、属性方法的隔离。

在实际应用中，主要有两种隔离方法：

1. diff 方法，一般用于兜底。

当子页面加载到父类的基座中的时候，我们可以生成一个 map 的散列表。在页面渲染之前，我们先把当前的 window 上的变量等都存储在这个 map 中。当页面卸载的时候，我们在遍历这个 map，将其数据在替换回去

需要注意的是，`JSON.parse(JSON.stringify(window))` 会报错，主要原因是因为 window 的属性中会有一个属性 window 循环指向自己本身，形成了循环引用。

```js
class SandBox {
  cacheCurrentWin = {};
  cacheBeforeWin = {};

  showPage() {
    this.cacheBeforeWin = {};
    // 加载页面之前，将window上的变量和方法都缓存到map中， 使用for...in copy 原型链上的属性方法
    for (const item in window) {
      this.cacheBeforeWin[item] = window[item];
    }
    Object.keys(this.cacheCurrentWin).forEach((item) => {
      window[item] = this.cacheCurrentWin[item];
    });
  }

  hidePage() {
    // 卸载页面时，再将之前存储的map重新替换回来
    for (const item in window) {
      if (this.cacheBeforeWin[item] !== window[item]) {
        // 缓存记录
        this.cacheCurrentWin[item] = window[item];
        // 还原window上的属性
        window[item] = this.cacheBeforeWin[item];
      }
    }
  }
}

window.info = '我是父应用';
const diffSandBox = new SandBox();
// 模拟激活子应用
diffSandBox.showPage();
window.info = '我是子应用';
console.log('页面激活，子应用对应的值', window.info);
// 模拟页面卸载
diffSandBox.hidePage();
console.log('页面卸载，主应用对应的值', window.info);
// 重新激活
diffSandBox.showPage();
console.log('页面激活，子应用对应的值', window.info);
```

2. 使用代理 `proxy`
   原理是，监听 get 和 set 方法，针对当前路由进行 window 的属性或方法的存取

```js
const windowMap = new Map(); // 使用路由作为key存储当前window的映射
const resetWindow = {}; // 被代理的对象
let routerUrl = ''; // 当前路由

const handler = {
  get(obj, key) {
    const win = windowMap.get(routerUrl);
    return win[key];
  },
  set(obj, key, value) {
    if (!windowMap.has(routerUrl)) {
      windowMap.set(routerUrl, JSON.parse(JSON.stringify(resetWindow)));
    }

    const win = windowMap.get(routerUrl);
    win[key] = value;
  },
};

const proxyA = new Proxy(resetWindow, handler);
// 基座 设置 属性
proxyA.info = '我是基座应用的info属性';

// 改变路由
routerUrl = '/routeA';
proxyA.info = '我是routeA应用下的info属性';

console.log(proxyA.info);

// 改变路由回到基座
routerUrl = '';
console.log(proxyA.info);

// 改变路由到子类
routerUrl = '/routeB';
proxyA.info = '我是routeB应用下的info属性';
console.log(proxyA.info);
```

## 业内产物

- single-spa
- 字节：[Garfish](!https://github.com/modern-js-dev/garfish)
- 阿里：[qiankun]()

## 遗留问题

- 当前这种方式解决了子应用和父应用中全局变量的冲突问题，那么基座中同时加载多个子应用系统呢？
- 通信如何解决的？
