## new 关键字做了什么？如何实现

1. 一个继承自 Fn 的实例对象 f1 被创建
2. `f1.__proto__ = Fn.prototype`, 将`f1.__proto__` 指向 `Fn.prototype`
3. 将 this 指向对象 f1
4. 返回新对象

- 如果构造函数没有显示的返回值，那么返回 this
- 如果构造函数显示的返回值为基础类型，那么返回 this
- 如果构造函数显示的返回值为对象，那么返回这个对象

```js
function newFn(Fn, ...args) {
  const newObj = Object.create(Fn);
  const resObj = Fn.call(newObj, ...args);
  return typeof resObj === 'object' ? resObj : newObj;
}

function newFn() {
  let o = new Object();
  const FunctionConstructor = [].shift.call(arguments); // 将第一个参数推出去， 即拿到构造函数
  o.__proto__ = FunctionConstructor.prototype;
  const resObj = FunctionConstructor.apply(o, arguments); // 此时的arguments只剩下除第一个参数之外的参数集合
  return typeof resObj === 'object' ? resObj : o;
}
```

## 原型继承

将子类的 prototype 指向父类的实例对象

```js
function Parent() {
  this.name = 'parent';
}
Parent.prototype.getName = () => console.log(this.name);

function Child() {}

// 实现继承就是说在child上找不到可以在其原型上去找，原型上找不到，可以在原型的原型上去找，依次套娃，所以要形成原型链，就是将__proto__和Prototype形成链条；
// child.__proto__ === Child.prototype;
// Child.prototype.__proto__ === Parent.prototype
const child = new Child();
// 实现了 Child.prototype.__proto__ === Parent.prototype，但是给Child.prototype重新赋值，就会丢失原有原型上的数据，特别重要的就是constructor这个属性，因此需要修正一下
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

隐含问题：

## 构造函数继承
